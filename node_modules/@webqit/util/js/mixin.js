
/**
 * @imports
 */
import _isArray from './isArray.js';
import _isFunction from './isFunction.js';
import _arrLast from '../arr/last.js';
import _mergeCallback from '../obj/mergeCallback.js';
import getPrototypeChain from '../obj/getPrototypeChain.js';
import _each from '../obj/each.js';

/**
 * A multi-inheritance implementstion.
 *
 * @param array	 	...classes
 *
 * @return object
 */
export default function mixin(...classes) {
	
	var Traps = {};
	var RetrnDirective = 'last';
	if (_isArray(arguments[0])) {
		classes = arguments[0];
		Traps = arguments[1];
		if (arguments[2]) {
			RetrnDirective = arguments[2];
		}
	}
	// -----------------------
	var Base = _arrLast(classes);
	var supersMap = {};
	// -----------------------
	// Create the Mixin
	// ...with a special constructor.
	// -----------------------
	var Mixin = class {
		constructor(...args) {
			var _this = null;
			classes.reverse().forEach((_class, i) => {
				var __this = Reflect.construct(_class, args, this.constructor);
				if (_this) {
					Object.setPrototypeOf(__this, _this);
				}
				_this = __this;
			});
			Object.setPrototypeOf(this, _this);
		}
	};
	// -----------------------
	// Implement a special handler of the "instanceof" operator.
	// -----------------------
	var WQSubclassesSymbolKey = Symbol.for('webqit/util/mixin');
	classes.forEach((_class, i) => {
		getPrototypeChain(_class).forEach(__class => {
			if (!__class[WQSubclassesSymbolKey]) {
				Object.defineProperty(__class, WQSubclassesSymbolKey, {value: []});
				try {
					var originalInstanceChecker = __class[Symbol.hasInstance].bind(__class);
					Object.defineProperty(__class, Symbol.hasInstance, {value: function(instance) {
						if (originalInstanceChecker(instance)) {
							return true;
						}
						return __class[WQSubclassesSymbolKey].reduce((yes, _mixin) => yes || (instance instanceof _mixin), false);
					}});
				} catch (e) {}
			}
			__class[WQSubclassesSymbolKey].push(Mixin);
		});
	});
	// ---------------------
	// Mixin both static and instance properties and methods
	// ---------------------
	classes.forEach(_class => {
		// Copy const members
		_mergeCallback([Mixin, _class], (prop, obj1, obj2) => ![
			'name', 'prototype', 'prototypes', 'length', 'caller', 'callee', 'arguments', 'constructor', 'apply', "bind", 'call', 'toString',/**/
		].includes(prop), true/*deepProps*/);
		_mergeCallback([Mixin.prototype, _class.prototype], (prop, obj1, obj2) => {
			if (!['prototype', 'prototypes'].includes(prop)) {
				if (_isFunction(obj2[prop])) {
					if (_isArray(supersMap[prop])) {
						supersMap[prop].push(obj2[prop]);
					} else {
						supersMap[prop] = [obj2[prop]];
					}
					return false;
				}
				return true;
			}
			return false;
		}, true/*deepProps*/);
	});
	// Extend (proxy) methods
	_each(supersMap, (prop, supers) => {
		if (prop === 'constructor') {
			return;
		}
		// NOTE: this must not be defined as an arrow function
		// for the benefit of the "this".
		Mixin.prototype[prop] = function(...args) {
			if (Object.hasOwnProperty(Traps, prop) && _isFunction(Traps[prop])) {
				// Wrap a call to the trap...
				// So mixin supers are passed to traps
				return Traps[prop].call(this, supers, ...args);
			} else {
				// Call each super and return
				// the last one's return value
				var supersReturnValues = [];
				supers.forEach(supr => {
					supersReturnValues.push(supr.call(this, ...args));
				})
				return _arrLast(supersReturnValues);
			}
		};
	});
	return Mixin;
};